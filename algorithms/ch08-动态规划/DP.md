# 动态规划基础

　　虽然我们在（一）中讨论过动态规划的装配线问题，但是究竟什么时候使用动态规划?那么我们就要清楚动态规划方法的最优化问题中的两个要素：最优子结构和重叠子问题。

## 1、**最优子结构**

1）如果问题的一个最优解包含了子问题的最优解，则该问题具有最优子结构。当一个问题具有最优子结构的时候，我们就可能要用到动态规划（贪心策略也是有可能适用的）。

2）寻找最优子结构时，可以遵循一种共同的模式：

1. 问题的一个解可以是一个选择。例如，装配站选择问题。

2. 假设对一个给定的问题，已知的是一个可以导致最优解的选择。不必关心如何确定这个选择，假定他是已知的。

3. 在已知这个选择之后，要确定那些子问题会随之发生，以及如何最好的描述所的得到的子问题空间。

4. 利用一种“剪贴”技术，来证明在问题的一个最优解中，使用的子问题的解本身也必须是最优的。


3）最优子结构在问题域中以两种方式变化：

1. 有多少个子问题被使用在原问题的一个最优解中，以及

2. 再决定一个最优解中使用那些子问题时有多少个选择


在装配线调度问题中，一个最优解只使用了一个子问题，但是，为确定一个最优解，我们必须考虑两种选择。

4）动态规划与贪心算法的区别

　　动态规划以自底向上的方式来利用最优子结构。也就是说，首先找到子问题的最优解，解决的子问题，然后找到问题的一个最优解。寻找问题的一个最优解需要首先在子问题中做出选择，即选择用哪一个来求解问题。问题解的代价通常是子问题的代价加上选择本身带来的开销。

　　在贪心算法中是以自顶向下的方式使用最优子结构。贪心算法会先做选怎，在当时看来是最优的选择，然后在求解一个结果子问题，而不是现寻找子问题的最优解，然后再做选择。

## 2、重叠子问题

　　适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要“很小”，也就是用来解原问题的递归算法可以反复的解同样的子问题，而不是总在产生新的子问题。典型的，不头痛的子问题数十输入规模的一个多项式，当一个递归算法不断的调用同一问题是，我们说该最优问题包含重叠子问题。

　　动态规划算法总是充分利用重叠子问题，即通过每个子问题只解一次，吧解保存在一个需要时就可以查看的表中，而每一次查表得时间为常数。



# 二叉树中的最大路径和

给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

**示例 1:**

```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

**示例 2:**

```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```



**解题思路**

1、最优子结构

因为树是由一个个更小的结点树组成，所以我们可以把问题分解成一个个更小的树。

当树的结点只有一个时，最大的路径就是他自身，让树的高度为2时，根节点的最大路径为左右结点中的最大值加上根节点本身的值：max(l, r) + root.val， 如果左右结点都为负数，还没有自身的值大呢，所以我们取其中的最大值。max_single = max(max(l, r) + root.val, root.val)

知道了二叉树的最优左右路径，我们需要比较整体路径，max_top = max(max_single, l+r+root.val)。

再将以该结点为根节点的二叉树的最大路径和，和全局的路径和比较，取两者最大值，res = max(res, max_top)

2、重叠子问题

从下往上走，当底层的最优路径找出来了， 上一层结点就能直接用下一层的结果,依次向上递推，求解过程都简化成了对若干个个高度为2 的二叉树的操作。当递归完成时，根节点的值就是整颗二叉树的最大路径和。

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def maxPathSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = float('-inf')
        self.find_max_path_sum(root)

        return self.res

    def find_max_path_sum(self, root):
        """ 
            定义find_max_path_sum(root)为返回path的最大和路径 
            path：经过root的path
        """
        # 空节点
        if not root:
            return 0

        # 最优子结构
        max_left = self.find_max_path_sum(root.left)
        max_right = self.find_max_path_sum(root.right)
        # max_single是以root为根的最大path，不包括left和right同时存在情况，它来作为返回值
        max_single = max(root.val, max(max_left, max_right)+root.val)
        # max_root是以root为根的最大path
        max_root = max(max_single,
                       max_left+max_right+root.val)
        #print("debug:",root.val, max_left, max_right, max_left+max_right+root.val) 

        if self.res <= max_root:
            self.res = max_root
        
        return max_single
        
```

